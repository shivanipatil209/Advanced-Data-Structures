import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.lang.Exception;
import java.util.List;
import java.io.FileWriter;
import java.io.PrintWriter;

public class gatorTaxi {
    MinHeap minHeap = new MinHeap();
    RBT rbt = new RBT();
    TreeNode nullNode;

    public static void main(String[] args) throws FileNotFoundException, IOException, Exception, NullPointerException {

        // Reading input file
        File inputFile = new File(args[0]);
        List<String> commands = new ArrayList<String>();
        FileReader fileReader = new FileReader(inputFile);
        String print1 = "Print\\(\\d+\\)";
        String print2 = "Print\\(\\d+,\\d+\\)";

        // loop running through command list and executing each command.
        try (BufferedReader bufferedReader = new BufferedReader(fileReader)) {
            FileWriter fileWriter = new FileWriter("output_file.txt");
            PrintWriter printWriter = new PrintWriter(fileWriter);

            gatorTaxi gt = new gatorTaxi();
            String request;
            while ((request = bufferedReader.readLine()) != null) {
                commands.add(request);
            }

            for (int i = 0; i < commands.size(); i++) {
                String[] temp = commands.get(i).split("\\(");
                String arguments = temp[1].substring(0, temp[1].length() - 1);
                String operation = temp[0];
                String[] arg = arguments.split(",");
                String output = null;

                // Condtional statements to check which operation needs to be performed.
                if (operation.equalsIgnoreCase("Insert")) {
                    output = gt.Insert(Integer.valueOf(arg[0]), Integer.valueOf(arg[1]),
                            Integer.valueOf(arg[2]));
                    // If Duplicate Ride NUmber is found, terminate the program
                    if (output != null && output.equalsIgnoreCase("Duplicate RideNumber")) {
                        printWriter.print(output);
                        break;
                    }
                } else if (operation.equalsIgnoreCase("Print")) {

                    if (commands.get(i).matches(print2)) {
                        output = gt.Print(Integer.valueOf(arg[0]), Integer.valueOf(arg[1]));
                    } else if (commands.get(i).matches(print1)) {
                        output = gt.Print(Integer.valueOf(arg[0]));
                    }

                } else if (operation.equalsIgnoreCase("GetNextRide")) {
                    output = gt.GetNextRide();
                } else if (operation.equalsIgnoreCase("UpdateTrip")) {
                    gt.UpdateTrip(Integer.valueOf(arg[0]), Integer.valueOf(arg[1]));
                } else if (operation.equalsIgnoreCase("CancelRide")) {
                    gt.CancelRide(Integer.valueOf(arg[0]));
                }
                // Checking whether output generated by operations is null And if not, writing
                // it to the output file.
                if (output != null) {
                    printWriter.print(output);
                    printWriter.print("\n");
                }

            }
            // Closing file writer
            printWriter.close();

        }
    }

    // Function to execute Print(rideNumber)
    public String Print(int rideNumber) {
        // Searching node in RBT
        TreeNode node = rbt.searchNode(rideNumber);
        // Check whether node is null or not. If it's null, return (0,0,0), else return
        // ride
        if (node.getRide() == null) {
            return "(0,0,0)";
        } else {

            String output = rbt.printRide(node.getRide());
            return output;
        }
    }

    // Function to execute Print(rideNumber1, rideNumber2)
    public String Print(int rideNumber1, int rideNumber2) {
        String output = rbt.inOrderHelper(rideNumber1, rideNumber2, rbt.getRoot());
        if (output.length() > 0) {
            output = output.substring(0, output.length() - 1);
            return output;
        }
        // Return (0,0,0), if no ride is found between the range
        else {
            return "(0,0,0)";
        }

    }

    // Function to insert the ride
    public String Insert(int rideNumber, int rideCost, int tripDuration) {
        Ride ride = new Ride(rideNumber, rideCost, tripDuration);
        TreeNode node = new TreeNode(ride);
        boolean flag = rbt.insertNode(node);
        // Flag is set to check whether ride already exists in database
        if (flag == true) {
            minHeap.insertNode(node);
            return null;
        } else {
            return "Duplicate RideNumber";
        }

    }

    // Function to return ride with minimum rideCost
    public String GetNextRide() throws Exception {
        Ride ride = minHeap.removeMin();
        if (ride != null) {
            rbt.deleteNode(ride.getRideNumber());
            String output = rbt.printRide(ride);
            return output;
        } else {
            return "No active ride requests";
        }

    }

    // Function to cancel ride from database
    public void CancelRide(int rideNumber) throws Exception {
        // Search ride in RBT, of found, delete it from database.
        TreeNode node = rbt.searchNode(rideNumber);
        if (node.getRide() != null) {
            rbt.deleteNode(rideNumber);
            minHeap.deleteArbitaryNode(node.heapIndex);
        }

    }

    // Function to update trip duration for given rideNumber
    public void UpdateTrip(int rideNumber, int new_tripDuration) throws Exception {
        // Searh ride in RBT
        TreeNode node = rbt.searchNode(rideNumber);

        Ride ride = node.getRide();

        // If ride found, perform required operations
        if (ride != null) {
            int existing_tripDuration = ride.getTripDuration();
            int rideCost = ride.getRideCost();

            // update ride with new tripDuration
            if (new_tripDuration <= existing_tripDuration) {
                rbt.updateNode(rideNumber, new_tripDuration);
                minHeap.decreaseTripDuration(node.getMinHeapIndex(), new_tripDuration);
            }

            else if (existing_tripDuration < new_tripDuration && new_tripDuration <= 2 * existing_tripDuration) {
                // Delete ride from database
                rbt.deleteNode(rideNumber);
                minHeap.deleteArbitaryNode(node.getMinHeapIndex());
                // Add new ride with same rideNUmber, increased rideCost and new tripDuration
                int new_rideCost = rideCost + 10;
                Insert(rideNumber, new_rideCost, new_tripDuration);
            }

            else if (new_tripDuration > 2 * existing_tripDuration) {
                // Delete ride from database.
                rbt.deleteNode(rideNumber);
                minHeap.deleteArbitaryNode(node.getMinHeapIndex());
            }
        }

    }
}
